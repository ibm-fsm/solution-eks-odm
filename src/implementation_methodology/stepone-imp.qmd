---
title: "Phase 1: Foundation & Prerequisite Configuration"
format: html
date: last-modified
---

## Phase 1: Foundation & Prerequisite Configuration

Before deploying the ODM application logic, the infrastructure foundation must be secured. This phase covers provisioning the database, generating internal TLS assets for end-to-end encryption, and creating the necessary Kubernetes secrets.

### 1.1 Database Provisioning (AWS RDS)

ODM requires a robust persistence layer. We utilize **AWS RDS for PostgreSQL** (v12+).

1.  **Provision RDS:** Ensure the instance is deployed in private subnets reachable by the EKS cluster.
2.  **Configure Security Groups:**
    *   **Inbound Rule:** Allow TCP/5432 from the EKS Cluster Security Group.
    *   **Outbound Rule:** Allow return traffic.

### 1.2 Schema & User Setup

The ODM data source requires specific privileges to initialize the schema on the first startup. Connect to your RDS instance via a bastion host or temporary pod and execute the following SQL commands:

```sql
-- 1. Create the dedicated ODM user
CREATE USER odm WITH PASSWORD 'StrongPassword123!';

-- 2. Create the database
CREATE DATABASE odm_db OWNER odm;

-- 3. Grant privileges (Required for table creation)
GRANT ALL PRIVILEGES ON DATABASE odm_db TO odm;

-- 4. (Optional) If using a specific schema
\c odm_db
CREATE SCHEMA odm_rules AUTHORIZATION odm;
```

### 1.3 Internal TLS Certificate Generation

To satisfy the OPA policy requiring HTTPS traffic at the cluster boundary, the Kubernetes Ingress resource must be configured with a valid TLS secret. This enables the Ingress Controller to terminate HTTPS traffic at the cluster boundary.

For this document, we will generate a self-signed certificate using OpenSSL.

**Generate the Certificate and Key (PEM):**

:::{.callout-note}
### Determining the Certificate Subject (CN)

The Common Name (`/CN`) in the certificate must match the exact Fully Qualified Domain Name (FQDN) that users will type into their browser.

*   **In the Lab:** We use the pattern `odm.<proxy>` (e.g., `/CN=odm.haproxy.gym.lan/O=Lab/C=US`). This ensures the browser accepts the certificate when traffic is routed through your lab's load balancer.
*   **In Production (AWS ALB):** Use the **Route53 CNAME** or Alias record created for the application (e.g., `/CN=odm.internal.corp`).
    *   *Important:* Do **not** use the raw AWS ALB hostname (e.g., `*.elb.amazonaws.com`) as the CN. Browser security policies will reject the certificate if it identifies the load balancer hardware rather than the application service name.
:::

```bash
# 1. Generate a self-signed certificate and private key
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout odm-lab.key \
  -out odm-lab.crt \
  -subj "/CN=odm.internal.corp/O=MyCorp/C=US"

# 2. Verify the content
ls -l odm-lab.key odm-lab.crt
```

### 1.4 Creating Kubernetes Secrets

With the database credentials defined and the keystore generated, inject them into the cluster as Kubernetes Secrets.

**Database Credentials Secret:**
This will be injected into the `server.xml` datasource configuration.

```bash
kubectl create secret generic odm-db-secret \
  --namespace odm-pilot \
  --from-literal=db-user=odm \
  --from-literal=db-password='StrongPassword123!' \
  --from-literal=db-name=odm_db \
  --from-literal=db-server=postgres.cxxxxx.us-east-1.rds.amazonaws.com
```

**TLS Keystore Secret:**
This will be referenced by the Ingress resource (`tlsSecretRef`) to enable HTTPS.

```bash
# Create a standard Kubernetes TLS secret type
kubectl create secret tls odm-tls-secret \
  --namespace odm-pilot \
  --key odm-lab.key \
  --cert odm-lab.crt
```

::: {.callout-note}
### Secret Management
In a production environment, avoid creating secrets from literals in the CLI history. Use an External Secrets Operator (ESO) to sync these values from AWS Secrets Manager or HashiCorp Vault.
:::

### 1.5 Create Image Pull Secret

Kubernetes requires authentication credentials to pull container images. Depending on your environment constraints (Lab vs. Restricted Production), the source registry and credentials will differ.

:::{.panel-tabset}

## Option A: Private Registry (Production/Restricted)
**Target Environment:** Customer Pilot / Air-Gapped / OPA-Enforced

In strict environments where public internet access is blocked or OPA forbids public registries, you must pull from the internal location where you mirrored the images (e.g., Artifactory).

**Action:** Create a secret using your internal registry credentials.

```bash
# Replace with your internal registry details
kubectl create secret docker-registry internal-registry-secret \
  --docker-server=artifactory.internal.corp:8443 \
  --docker-username=<SERVICE_ACCOUNT_USER> \
  --docker-password=<SERVICE_ACCOUNT_TOKEN> \
  --docker-email=admin@internal.corp \
  -n odm-pilot
```

## Option B: IBM Registry (Standard Lab)
**Target Environment:** Sandbox / POC with Internet Access

If you are working in a lab with direct internet access and no strict OPA registry constraints, you can pull directly from IBM.

**Action:** Create a secret using your IBM Entitlement Key.

```bash
# 1. Get your key from myibm.ibm.com/products-services/containerlibrary
# 2. Create the secret
kubectl create secret docker-registry ibm-entitlement-key \
  --docker-server=cp.icr.io \
  --docker-username=cp \
  --docker-password=<YOUR_IBM_ENTITLEMENT_KEY> \
  --docker-email=user@example.com \
  -n odm-pilot
```
:::

:::{.callout-important}
### Secret Name Consistency
Whichever option you choose, ensure the secret name used in the `kubectl create` command exactly matches the value in your `values.yaml` file under `image.pullSecrets`.
:::